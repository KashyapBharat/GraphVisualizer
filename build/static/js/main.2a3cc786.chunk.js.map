{"version":3,"sources":["components/Node.jsx","components/Dijkstra.jsx","components/Astar.jsx","components/GreedyBFS.jsx","components/App.jsx","components/Header.jsx","index.js"],"names":["Node","props","onClick","Clickfunc","rowid","colid","onMouseDown","setter","onMouseEnter","Bool","onMouseUp","className","isWall","isStart","isEnd","isExp","isPat","isVis","dijkstra","grid","isVisited","isExplored","isPath","start","end","dx","dy","dist","prev","i","distRow","prevRow","j","push","Infinity","queue","length","sz","curr","shift","setTimeout","temp","next","Astar","distance","x1","y1","Math","abs","xxdist","xrow","dis","index","st","c","GreedyBFS","x2","y2","Header","class","style","backgroundColor","color","currentRow","isParent","App","useState","board","setboard","setTest","setBool","handleClick","rowd","cold","random","console","log","map","row","key","col","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.2a3cc786.chunk.js","sourcesContent":["import React from \"react\";\n\nfunction Node(props) \n{\n   return (\n   <div \n   onClick={()=>props.Clickfunc([props.rowid,props.colid])} \n   onMouseDown={()=>props.setter(true)} \n   onMouseEnter={()=>props.Bool && props.Clickfunc([props.rowid,props.colid])} \n   onMouseUp={()=>props.setter(false)} \n   \n                                                                            className={props.isWall? \"isWall\": \n                                                                            props.isStart? \"isSrt\":\n                                                                            props.isEnd? \"isEnd\": \n                                                                            props.isExp? \"isExplore\":\n                                                                            props.isPat? \"Path\":\n                                                                            props.isVis? \"isVisit\":\"node\"}\n   ></div>\n   );\n}\nexport default Node;\n","function dijkstra (grid, isVisited, isExplored, isPath){\r\n\r\n    const start = [2, 2],\r\n      end = [10, 45];\r\n    const dx = [0, 1, 0, -1],\r\n      dy = [1, 0, -1, 0];\r\n  \r\n    let dist = [],\r\n      prev = [];\r\n    for (let i = 0; i < 15; i++) {\r\n      let distRow = [],\r\n        prevRow = [];\r\n      for (let j = 0; j < 50; j++) {\r\n        distRow.push(Infinity);\r\n        prevRow.push([i, j]);\r\n      }\r\n      dist.push(distRow);\r\n      prev.push(prevRow);\r\n    }\r\n  \r\n    dist[start[0]][start[1]] = 0;\r\n  \r\n    let queue = [];\r\n    queue.push(start);\r\n    while (queue.length > 0) {\r\n      let sz = queue.length;\r\n      for (let i = 0; i < sz; i++) {\r\n        let curr = queue.shift();\r\n          setTimeout(() => isVisited(curr), 0);\r\n        if (curr[0] === end[0] && curr[1] === end[1]) {\r\n          curr = prev[curr[0]][curr[1]];\r\n          while (true) {\r\n            let temp = curr;\r\n            setTimeout(() => isPath(temp), 0);\r\n            if (curr === start) {\r\n              break;\r\n            }\r\n            curr = prev[curr[0]][curr[1]];\r\n          }\r\n          return;\r\n        }\r\n        for (let i = 0; i < 4; i++) {\r\n          let next = [curr[0] + dx[i], curr[1] + dy[i]];\r\n          if (\r\n            next[0] >= 0 &&\r\n            next[0] < 15 &&\r\n            next[1] >= 0 &&\r\n            next[1] < 50 &&\r\n            !grid[next[0]][next[1]].isWall &&\r\n            !grid[next[0]][next[1]].isVisited &&\r\n            dist[next[0]][next[1]] > 1 + dist[curr[0]][curr[1]]\r\n          ) {\r\n            queue.push(next);\r\n            prev[next[0]][next[1]] = curr;\r\n            dist[next[0]][next[1]] = 1 + dist[curr[0]][curr[1]];\r\n            setTimeout(() => isExplored(next), 0);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    setTimeout(() => isPath(start), 0);\r\n  };\r\n  \r\n  export default dijkstra;","function Astar(grid, isVisited, isExplored, isPath) {\r\n    const start = [2, 2],\r\n      end = [10, 45];\r\n    const dx = [0, 1, 0, -1],\r\n      dy = [1, 0, -1, 0];\r\n  \r\n    function distance(x1, y1) {\r\n      return Math.abs(x1 - end[0]) + Math.abs(y1 - end[1]);\r\n    }\r\n  \r\n    let dist = [],\r\n      xxdist = [],\r\n      prev = [];\r\n    for (let i = 0; i < 15; i++) {\r\n      let distRow = [],\r\n        prevRow = [],\r\n        xrow = [];\r\n      for (let j = 0; j < 50; j++) {\r\n        distRow.push(Infinity);\r\n        xrow.push(Infinity);\r\n        prevRow.push([i, j]);\r\n      }\r\n      dist.push(distRow);\r\n      xxdist.push(xrow);\r\n      prev.push(prevRow);\r\n    }\r\n  \r\n    dist[start[0]][start[1]] = distance(start[0], start[1]);\r\n    xxdist[start[0]][start[1]] = 0;\r\n    let queue = [];\r\n    queue.push(start);\r\n    while (queue.length > 0) {\r\n      let sz = queue.length;\r\n      const [x1, y1] = queue[0];\r\n      let dis = dist[x1][y1];\r\n      let index = 0;\r\n      for (let j = 1; j < sz; j++) {\r\n        let [x1, y1] = queue[j];\r\n        if (dis > dist[x1][y1]) {\r\n          dis = dist[x1][y1];\r\n          index = j;\r\n        } else if (dis === dist[x1][y1]) {\r\n          let [x, y] = queue[index];\r\n          if (distance(x, y) > distance(x1, y1)) {\r\n            index = j;\r\n          }\r\n        }\r\n      }\r\n      let temp = queue[0];\r\n      queue[0] = queue[index];\r\n      queue[index] = temp;\r\n      let curr = queue.shift();\r\n      setTimeout(() => isVisited(curr), 0);\r\n      if (curr[0] === end[0] && curr[1] === end[1]) {\r\n        curr = prev[curr[0]][curr[1]];\r\n        let st = [];\r\n        st.push(curr);\r\n        while (true) {\r\n          let temp = curr;\r\n          st.push(temp);\r\n          if (curr === start) {\r\n            for (let j = 0; j < st.length; j++) {\r\n              setTimeout(() => isPath(st[j]), 0);\r\n            }\r\n            return;\r\n          }\r\n          curr = prev[curr[0]][curr[1]];\r\n        }\r\n      }\r\n      for (let i = 0; i < 4; i++) {\r\n        let next = [curr[0] + dx[i], curr[1] + dy[i]];\r\n        if (\r\n          next[0] >= 0 &&\r\n          next[0] < 15 &&\r\n          next[1] >= 0 &&\r\n          next[1] < 50 &&\r\n          !grid[next[0]][next[1]].isWall &&\r\n          !grid[next[0]][next[1]].isVisited &&\r\n          dist[next[0]][next[1]] > 1 + dist[curr[0]][curr[1]]\r\n        ) {\r\n          queue.push(next);\r\n          prev[next[0]][next[1]] = curr;\r\n          xxdist[next[0]][next[1]] = xxdist[curr[0]][curr[1]] + 1;\r\n          let c = xxdist[next[0]][next[1]];\r\n          dist[next[0]][next[1]] = distance(next[0], next[1]) + c;\r\n          setTimeout(() => isExplored(next), 0);\r\n        }\r\n      }\r\n    }\r\n    setTimeout(() => isPath(start), 0);\r\n  }\r\n  \r\n  export default Astar;\r\n  ","function GreedyBFS(grid, isVisited, isExplored, isPath) {\r\n\r\n    const start = [2, 2],\r\n      end = [10, 45];\r\n    const dx = [0, 1, 0, -1],\r\n      dy = [1, 0, -1, 0];\r\n  \r\n    function distance(x1, y1, x2, y2) {\r\n      return Math.abs(x1 - x2) + Math.abs(y1 - y2);\r\n    }\r\n  \r\n    let dist = [],\r\n      prev = [];\r\n    for (let i = 0; i < 15; i++) {\r\n      let distRow = [],\r\n        prevRow = [];\r\n      for (let j = 0; j < 50; j++) {\r\n        distRow.push(Infinity);\r\n        prevRow.push([i, j]);\r\n      }\r\n      dist.push(distRow);\r\n      prev.push(prevRow);\r\n    }\r\n  \r\n    dist[start[0]][start[1]] = 0;\r\n  \r\n    let queue = [];\r\n    queue.push(start);\r\n    while (queue.length > 0) {\r\n      let sz = queue.length;\r\n      const [x1, y1] = queue[0];\r\n      let dis = distance(x1, y1, end[0], end[1]);\r\n      let index = 0;\r\n      for (let j = 1; j < sz; j++) {\r\n        let [x1, y1] = queue[j];\r\n        if (dis > distance(x1, y1, end[0], end[1])) {\r\n          dis = distance(x1, y1, end[0], end[1]);\r\n          index = j;\r\n        }\r\n      }\r\n      let temp = queue[0];\r\n      queue[0] = queue[index];\r\n      queue[index] = temp;\r\n      let curr = queue.shift();\r\n      setTimeout(() => isVisited(curr), 0);\r\n      if (curr[0] === end[0] && curr[1] === end[1]) {\r\n        curr = prev[curr[0]][curr[1]];\r\n        while (true) {\r\n          let temp = curr;\r\n          setTimeout(() => isPath(temp), 0);\r\n          if (curr === start) {\r\n            break;\r\n          }\r\n          curr = prev[curr[0]][curr[1]];\r\n        }\r\n        return;\r\n      }\r\n      for (let i = 0; i < 4; i++) {\r\n        let next = [curr[0] + dx[i], curr[1] + dy[i]];\r\n        if (\r\n          next[0] >= 0 &&\r\n          next[0] < 15 &&\r\n          next[1] >= 0 &&\r\n          next[1] < 50 &&\r\n          !grid[next[0]][next[1]].isWall &&\r\n          !grid[next[0]][next[1]].isVisited &&\r\n          !grid[next[0]][next[1]].isExplored &&\r\n          dist[next[0]][next[1]] > 1 + dist[curr[0]][curr[1]]\r\n        ) {\r\n          queue.push(next);\r\n          prev[next[0]][next[1]] = curr;\r\n          dist[next[0]][next[1]] = 1 + dist[curr[0]][curr[1]];\r\n          setTimeout(() => isExplored(next), 0);\r\n        }\r\n      }\r\n    }\r\n    setTimeout(() => isPath(start), 0);\r\n  }\r\n  \r\n  export default GreedyBFS;\r\n  ","import React, { useState } from \"react\";\nimport Node from \"./Node\";\nimport dijkstra from \"./Dijkstra\";\nimport Astar from \"./Astar\";\nimport GreedyBFS from \"./GreedyBFS\";\nimport Header from \"./Header\";\n\nlet ROW_LENGTH=15;\nlet COL_LENGTH=50;\nconst grid = [];\n\n  for (let i = 0; i < ROW_LENGTH; i++) \n  {\n  const currentRow = [];\n  for (let j = 0; j < COL_LENGTH; j++) {\n    currentRow.push({\n      rowid:i,\n      colid:j,\n      isStart:false,\n      isEnd:false,\n      isVis:false,\n      isWall:false,\n      isPat:false,\n      isExp:false,\n      isParent:[]\n      // more props?\n    });\n  }\n    grid.push(currentRow);\n  }\n\ngrid[2][2].isStart=true;\ngrid[10][45].isEnd=true;  \n\nfunction App() \n{\n\n  const[board,setboard]=useState(grid);\n  const[test,setTest]=useState(0);\n  const[Bool,setBool]=useState(false);\n\nfunction resetBoard()\n{\n  let ROW_LENGTH=15;\n  let COL_LENGTH=50;\n\n  for (let i = 0; i < ROW_LENGTH; i++) \n  {\n  for (let j = 0; j < COL_LENGTH; j++) \n  {\n      if(!board[i][j].isWall){\n      grid[i][j].rowid=i;\n      grid[i][j].colid=j;\n      grid[i][j].isStart=false;\n      grid[i][j].isEnd=false;\n      grid[i][j].isVis=false;\n      grid[i][j].isWall=false;\n      grid[i][j].isPat=false;\n      grid[i][j].isExp=false;\n      grid[i][j].isParent=[];\n      // more props?\n      }\n    }\n  }\n  grid[2][2].isStart=true;\n  grid[10][45].isEnd=true; \n  setboard(grid);\n  setTest(Math.random());\n}\n\nfunction clearBoard()\n{\n  let ROW_LENGTH=15;\n  let COL_LENGTH=50;\n\n  for (let i = 0; i < ROW_LENGTH; i++) \n  {\n  for (let j = 0; j < COL_LENGTH; j++) \n  {\n      grid[i][j].rowid=i;\n      grid[i][j].colid=j;\n      grid[i][j].isStart=false;\n      grid[i][j].isEnd=false;\n      grid[i][j].isVis=false;\n      grid[i][j].isWall=false;\n      grid[i][j].isPat=false;\n      grid[i][j].isExp=false;\n      grid[i][j].isParent=[]\n      // more props?\n    }\n  }\n  grid[2][2].isStart=true;\n  grid[10][45].isEnd=true; \n  setboard(grid);\n  setTest(Math.random());\n}\n\ngrid[2][2].isStart=true;\ngrid[10][45].isEnd=true; \n  \n  function handleClick([rowd,cold])\n  {\n      if(grid[rowd][cold].isStart || grid[rowd][cold].isEnd) return;\n      grid[rowd][cold].isWall^=true;\n      setboard(grid);\n      setTest(Math.random());\n  }\n  \n  function isVisited([rowd,cold])\n  {\n    if(!grid[rowd][cold].isStart && !grid[rowd][cold].isEnd)\n    {\n    grid[rowd][cold].isVis=true;\n    grid[rowd][cold].isExp=false;\n    console.log(\"VIS\");\n    //grid[rowd][cold].isPat=false;\n    // console.log(grid[3][6].isVis);\n    setboard(grid);\n    setTest(Math.random());\n    }\n    setTest(Math.random());\n  }\n\n  function isExplored([rowd,cold])\n  {\n    if(!grid[rowd][cold].isStart && !grid[rowd][cold].isEnd)\n    {\n    //grid[rowd][cold].isVis=true;\n    grid[rowd][cold].isExp=true;\n    //grid[rowd][cold].isVis=false;\n    console.log(\"EXP\");\n    //console.log(\"MISHRA\");\n    setboard(grid);\n    setTest(Math.random());\n    }\n    setTest(Math.random());\n  }\n\n  function isPath([rowd,cold])\n  {\n    if(!grid[rowd][cold].isStart && !grid[rowd][cold].isEnd)\n    {\n    //console.log(rowd+\" \"+cold);\n    //setTimeout(() => isPath([rowd,cold]),1000);\n    grid[rowd][cold].isPat=true;\n    grid[rowd][cold].isExp=false;\n    //grid[rowd][cold].isVis=false;\n    console.log(\"PATH\");\n    setboard(grid);\n    setTest(Math.random());\n    }\n    setTest(Math.random());\n  }\n\n\n  return(\n  <div class=\"Marg\">\n  <Header></Header> \n  {board.map((row, rowid) => {\n    return (<div className=\"ROW\" key={rowid}>\n    {row.map((col,colid) =>{\n      return (\n        <Node key={[rowid,colid]} rowid={col.rowid} colid={col.colid} isStart={col.isStart} isEnd={col.isEnd} \n        isVis={col.isVis} isWall={col.isWall} isPat={col.isPat} isExp={col.isExp}\n         Clickfunc={handleClick} Bool={Bool} setter={setBool}>\n        </Node>\n        );})}\n    </div>);})}\n    <button className=\"btn btn-lg btn-primary clicker\" onClick={resetBoard}>RESET</button>\n    <button className=\"btn btn-lg btn-success clicker\" onClick={clearBoard}>CLEAR</button>\n    <button className=\"btn btn-lg btn-danger clicker\" onClick={()=>dijkstra(grid,isVisited,isExplored,isPath,)}>Dijkstra</button>\n    <button className=\"btn btn-lg btn-warning clicker\" onClick={()=>Astar(grid,isVisited,isExplored,isPath,)}>A-STAR</button>\n    <button className=\"btn btn-lg btn-info clicker\" onClick={()=>GreedyBFS(grid,isVisited,isExplored,isPath,)}>Greedy BFS</button>\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\r\n\r\nfunction Header() {\r\n  return (\r\n    <header>\r\n    <nav class=\"navbar navbar-light\" style={{backgroundColor: 'gray'}}>\r\n    <h1>Path Visualizer</h1>\r\n    <h2 style={{ color: 'black'}}>Wall</h2>\r\n    <h2 style={{ color: 'orange' }}>Explored</h2>\r\n    <h2 style={{ color: 'blue' }}>Path</h2>\r\n    <h2 style={{ color: 'red' }}>End</h2>\r\n    <h2 style={{ color: 'yellow' }}>Visited</h2>\r\n    <h2 style={{ color: 'green' }}>Start</h2>\r\n       </nav>\r\n    {/* <h2>Instructions:</h2>  \r\n    <l>\r\n        <li>Double Click to select Start Point(appears in Green)</li>\r\n        <li>After selecting Start Point, Double Click to select End Point(appears in Red)</li>\r\n        <li>Click and Drag to add impenetrable Walls(appears in Black)</li>\r\n        <li>Select the desired Algorithm</li>\r\n    </l> */}\r\n    </header>\r\n  );\r\n}\r\n\r\nexport default Header;\r\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./components/App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}